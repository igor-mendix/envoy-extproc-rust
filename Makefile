# Makefile

# --- Configuration ---
CARGO_CMD            := cargo
BAZEL_CMD            := bazel
GIT_CMD              := git
DOCKER_CMD           := docker

# Build Flags
CARGO_BUILD_FLAGS    :=
CARGO_RELEASE_FLAGS  := --release

# Envoy Repository Configuration
ENVOY_TAG            := v1.34.0
ENVOY_REPO_URL       := https://github.com/envoyproxy/envoy.git
ENVOY_CLONE_DIR      := envoy_repo

# Root .proto path (just for ordering/dependencies in Make)
ROOT_PROTO_FILE_REL  := api/envoy/service/ext_proc/v3/external_processor.proto
ROOT_PROTO_FILE_ABS  := $(ENVOY_CLONE_DIR)/$(ROOT_PROTO_FILE_REL)

# Files generated by the Make process
BAZEL_OUTPUT_BASE_FILE := bazel_output_base.txt
DEPS_STAMP             := .bazel-deps-fetched

CLONE_MARKER           := $(ENVOY_CLONE_DIR)/.makefile_clone_complete

# Where tonic-build will look for imports
ENVOY_API_DIR        := $(CURDIR)/$(ENVOY_CLONE_DIR)/api
export ENVOY_API_DIR

# Docker image info
ifndef IMAGE_NAME
IMAGE_NAME           := igormendix/rust-extproc-server
endif
IMAGE_TAG            := $(shell date +%Y%m%d)
LATEST_TAG           := latest

# Default target
all: release

# === Rust builds ===

build: fetch-deps
	@echo "+++ Building Rust Project (Debug) +++"
	$(CARGO_CMD) build $(CARGO_BUILD_FLAGS)
	@echo "+++ Rust debug build finished +++"

release: fetch-deps
	@echo "+++ Building Rust Project (Release) +++"
	$(CARGO_CMD) build $(CARGO_RELEASE_FLAGS) $(CARGO_BUILD_FLAGS)
	@echo "+++ Rust release build finished +++"

# === Clone Envoy & fetch all dependencies ===

clone-envoy: $(CLONE_MARKER)

$(CLONE_MARKER):
	@echo "+++ Cloning Envoy Repository (tag: $(ENVOY_TAG)) +++"
	$(GIT_CMD) clone --depth 1 --branch $(ENVOY_TAG) \
	  $(ENVOY_REPO_URL) $(ENVOY_CLONE_DIR)
	@touch $(CLONE_MARKER)

$(BAZEL_OUTPUT_BASE_FILE): clone-envoy
	@echo "+++ Bazel fetch //… inside $(ENVOY_CLONE_DIR) +++"
	cd $(ENVOY_CLONE_DIR) && $(BAZEL_CMD) fetch //...
	@echo "+++ Recording Bazel output_base +++"
	cd $(ENVOY_CLONE_DIR) && \
	  $(BAZEL_CMD) info output_base | tr -d '\n' \
	    > $(CURDIR)/$(BAZEL_OUTPUT_BASE_FILE)

# fetch-deps is a phony alias for “make sure DEPS_STAMP exists”
.PHONY: fetch-deps
fetch-deps: $(DEPS_STAMP)

# the *only* place bazel actually runs is here,
# and once .bazel-deps-fetched exists, it never runs again
$(DEPS_STAMP): $(BAZEL_OUTPUT_BASE_FILE)
	@echo "+++ Bazel deps fetched and output_base recorded +++"
	@touch $(DEPS_STAMP)

# === Docker targets ===

docker-build:
	@echo "+++ Building Docker Image $(IMAGE_NAME):$(IMAGE_TAG) & :$(LATEST_TAG) +++"
	$(DOCKER_CMD) build --platform linux/amd64 \
	  -t $(IMAGE_NAME):$(IMAGE_TAG) \
	  -t $(IMAGE_NAME):$(LATEST_TAG) .

docker-push: docker-build
	@echo "+++ Pushing Docker Image +++"
	$(DOCKER_CMD) push $(IMAGE_NAME):$(IMAGE_TAG)
	$(DOCKER_CMD) push $(IMAGE_NAME):$(LATEST_TAG)

docker-login:
	@echo "+++ Docker login +++"
	$(DOCKER_CMD) login

docker-clean:
	@echo "+++ Pruning dangling Docker images +++"
	$(DOCKER_CMD) image prune -af

build-push: docker-build docker-push

# === Clean ===

rust-clean:
	@echo "+++ Cleaning Rust artifacts +++"
	$(CARGO_CMD) clean
	@echo "+++ Removing clone marker, bazel base file and deps stamp +++"
	rm -f $(CLONE_MARKER) $(BAZEL_OUTPUT_BASE_FILE) $(DEPS_STAMP)

clean: rust-clean docker-clean
	@echo "+++ Full clean complete +++"

.PHONY: all build release clone-envoy \
        docker-build docker-push docker-login docker-clean \
        build-push clean rust-clean

